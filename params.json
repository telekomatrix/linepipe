{"name":"Linepipe","tagline":"A tool to aid in processing data in a pipeline, making every step easily testable and benchmarkable.","body":"# Linepipe\r\n\r\nA tool to aid in processing data in a pipeline, making every step easily\r\ntestable and benchmarkable.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'linepipe'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install linepipe\r\n\r\n## Usage\r\n\r\nLinepipe's DSL consists of 4 different parts:\r\n\r\n* `setup`: Optional setup that will be run at the beginning.\r\n* `data`: The input data.\r\n* `process`: As many of these as you want will conform the steps of your\r\n  algorithm.\r\n* `expect`: In development mode, each of these will be run against your final\r\n  output data to ensure its conformity with your expectations.\r\n\r\nWhile developing a processing algorithm, `Linepipe.develop` is your friend. Each\r\n`process` block will be reduced against your data in order, and then each\r\n`expect` block will be run against the final output to ensure that it works.\r\n\r\n```ruby\r\nlinepipe = Linepipe.run do\r\n  data {\r\n    %w(foo bar baz)\r\n  }\r\n\r\n  process(\"Upcasing\") { |data|\r\n    data.map(&:upcase)\r\n  }\r\n\r\n  process(\"Reversing\") { |data|\r\n    data.reverse\r\n  }\r\n\r\n  expect { |data|\r\n    data == %w(BAZ BAR FOO)\r\n  }\r\nend\r\n\r\nlinepipe.result # => %W(BAZ BAR FOO)\r\n```\r\n\r\nOnce you're comfortable with your algorithm, just change your call to\r\n`Linepipe.develop` to `Linepipe.run` and no expectations will be run.\r\n\r\n## Testing your linepipes\r\n\r\n`Linepipe.run`, `Linepipe.benchmark` and `Linepipe.develop` return a `Linepipe::Process` object that\r\nresponds to two important methods: `output` and a hash-like\r\ninterface to access each step. In our case above we would access the second step\r\n\"Reversing\" (from a test or wherever) like this:\r\n\r\n```ruby\r\nstep = linepipe[\"Reversing\"]\r\n# => #<Step ...>\r\nexpect(step.apply([1,2,3])).to eq([3,2,1])\r\n# => [3,2,1]\r\n```\r\n\r\nThis way you can test every stage of your linepipe separately against as many\r\ninputs as you want.\r\n\r\n## Benchmarking your linepipes\r\n\r\nTo switch Linepipe into benchmark mode, just call `Linepipe.benchmark` instead\r\nof `.develop` or `.run`. This will print a detailed benchmark for every step of\r\nyour algorithm so you can easily identify and fix bottlenecks.\r\n\r\n```ruby\r\nlinepipe = Linepipe.benchmark(10_000) do\r\n  data {\r\n    %w(foo bar baz)\r\n  }\r\n\r\n  process(\"Upcasing\") { |data|\r\n    data.map(&:upcase)\r\n  }\r\n\r\n  process(\"Reversing\") { |data|\r\n    data.reverse\r\n  }\r\n\r\n  expect { |data|\r\n    data == %w(BAZ BAR FOO)\r\n  }\r\nend\r\n```\r\n\r\nWill output to the screen:\r\n\r\n    Rehearsal ---------------------------------------------\r\n    Upcasing    0.020000   0.000000   0.020000 (  0.024458)\r\n    Reversing   0.000000   0.000000   0.000000 (  0.004000)\r\n    ------------------------------------ total: 0.020000sec\r\n\r\n                    user     system      total        real\r\n    Upcasing    0.020000   0.000000   0.020000 (  0.022565)\r\n    Reversing   0.010000   0.000000   0.010000 (  0.007034)\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n## License\r\n\r\nCopyright (c) 2013 Wimdu GmbH (MIT License). See LICENSE.txt for details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}